<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Transcription Vocale Accessible</title>
    <script>
        // Applique le thème sombre avant le rendu de la page pour éviter le flash
        if (localStorage.getItem('voiceNoteTheme_v1') === 'dark' || (!('voiceNoteTheme_v1' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
            document.documentElement.classList.add('dark');
        } else {
            document.documentElement.classList.remove('dark');
        }
    </script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Atkinson+Hyperlegible:wght@400;700&display=swap" rel="stylesheet">
    <style>
        html { height: -webkit-fill-available; }
        body {
            font-family: 'Atkinson Hyperlegible', sans-serif;
            display: flex;
            flex-direction: column;
            height: 100vh;
            height: 100dvh;
            overflow: hidden;
            background-color: #f9fafb; /* bg-gray-50 */
            color: #111827; /* text-gray-900 */
        }
        .dark body {
            background-color: #111827; /* bg-gray-900 */
            color: #f3f4f6; /* text-gray-100 */
        }
        #text-container {
            flex: 1 1 auto;
            font-size: 22px;
            line-height: 1.6;
            touch-action: pan-y; 
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        #transcript {
            color: #111827; /* Equivalent de text-gray-900 */
        }
        .dark #transcript {
            color: #f3f4f6; /* Equivalent de text-gray-100 */
        }
        footer { flex-shrink: 0; }
        .is-listening { animation: pulse-red 1.5s infinite; }
        @keyframes pulse-red {
            0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
            70% { box-shadow: 0 0 0 25px rgba(239, 68, 68, 0); }
            100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
        }
        .switch { position: relative; display: inline-block; width: 50px; height: 28px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 28px; }
        .slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #2563eb; }
        input:checked + .slider:before { transform: translateX(22px); }

        /* Styles pour le panneau latéral */
        #settings-panel {
            transform: translateX(100%);
            transition: transform 0.3s ease-in-out;
        }
        #settings-panel.is-open {
            transform: translateX(0);
        }
    </style>
</head>
<body>

    <!-- Panneau de paramètres -->
    <div id="settings-panel" class="fixed top-0 right-0 h-full w-72 bg-white dark:bg-gray-700 shadow-xl z-50 p-6">
        <h2 class="text-2xl font-bold mb-6 text-gray-800 dark:text-gray-100">Paramètres</h2>

        <!-- Theme Switcher -->
        <div class="flex items-center justify-between mb-6">
            <span class="text-gray-700 dark:text-gray-100">Thème Sombre</span>
            <label class="switch">
                <input type="checkbox" id="themeToggle">
                <span class="slider"></span>
            </label>
        </div>

        <!-- Language Selector -->
        <div class="flex items-center justify-between mb-6">
            <label for="lang-select" class="text-gray-700 dark:text-gray-100">Langue</label>
            <select id="lang-select" class="bg-gray-200 dark:bg-gray-600 border border-gray-300 dark:border-gray-500 text-gray-900 dark:text-gray-100 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 p-2">
                <option value="fr-FR">Français</option>
                <option value="en-US">English (US)</option>
                <option value="es-ES">Español</option>
                <option value="de-DE">Deutsch</option>
                <option value="it-IT">Italiano</option>
            </select>
        </div>

        <!-- Font Size Controls -->
        <div class="flex items-center justify-between mb-4">
            <label for="min-font-size" class="text-gray-700 dark:text-gray-100">Taille min police</label>
            <input type="number" id="min-font-size" class="w-20 bg-gray-200 dark:bg-gray-600 border border-gray-300 dark:border-gray-500 text-gray-900 dark:text-gray-100 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 p-2" min="8" max="40">
        </div>
        <div class="flex items-center justify-between mb-6">
            <label for="max-font-size" class="text-gray-700 dark:text-gray-100">Taille max police</label>
            <input type="number" id="max-font-size" class="w-20 bg-gray-200 dark:bg-gray-600 border border-gray-300 dark:border-gray-500 text-gray-900 dark:text-gray-100 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 p-2" min="50" max="200">
        </div>

        <a href="help.html" class="mt-8 inline-block bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">
            Aide
        </a>
    </div>
     <!-- Overlay pour fermer le panneau -->
    <div id="overlay" class="fixed inset-0 bg-black bg-opacity-50 z-40 hidden"></div>


    <div id="text-container" class="relative w-full p-4 text-left select-none">
        <p id="transcript" class="whitespace-pre-wrap"></p>
    </div>
    <div id="zoom-indicator" class="fixed top-4 right-4 bg-gray-900 bg-opacity-75 text-white text-sm rounded-md px-3 py-1 transition-opacity duration-300 opacity-0 pointer-events-none z-50"></div>

    <footer class="w-full p-4 bg-white dark:bg-gray-800 border-t border-gray-200 dark:border-gray-700 shadow-t-lg pb-8 md:pb-4">
        <p id="status" class="text-center text-gray-500 dark:text-gray-400 mb-4 h-6 transition-all duration-300">Maintenez pour parler</p>
        <div class="relative flex justify-center items-center space-x-5">
            <button id="clearButton" class="bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-800 dark:text-gray-200 rounded-full p-4 transition-transform duration-200 active:scale-90 shadow-md" title="Effacer le texte">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg>
            </button>
            
            <button id="micButton" class="bg-blue-600 text-white rounded-full p-5 transition-all duration-300 shadow-lg" title="Maintenir pour parler">
                <svg id="micIcon" xmlns="http://www.w3.org/2000/svg" class="h-7 w-7" viewBox="0 0 24 24" fill="currentColor"><path d="M12 14c1.66 0 2.99-1.34 2.99-3L15 5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zM17.3 11c0 3-2.54 5.1-5.3 5.1S6.7 14 6.7 11H5c0 3.41 2.72 6.23 6 6.72V21h2v-3.28c3.28-.48 6-3.3 6-6.72h-1.7z"/></svg>
            </button>
            
            <div class="flex flex-col items-center">
                <label class="switch">
                    <input type="checkbox" id="modeToggle">
                    <span class="slider"></span>
                </label>
                <span class="text-xs text-gray-500 dark:text-gray-400 mt-1">Continu</span>
            </div>

            <button id="settingsButton" class="absolute right-4 top-1/2 -translate-y-1/2 bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-600 dark:text-gray-300 rounded-full p-3 transition-transform duration-200 active:scale-90 shadow-md" title="Paramètres">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M11.49 3.17c-.38-1.56-2.6-1.56-2.98 0a1.532 1.532 0 01-2.286.948c-1.372-.836-2.942.734-2.106 2.106.54.886.061 2.042-.947 2.287-1.561.379-1.561 2.6 0 2.978a1.532 1.532 0 01.947 2.287c-.836 1.372.734 2.942 2.106 2.106a1.532 1.532 0 012.287.947c.379 1.561 2.6 1.561 2.978 0a1.532 1.532 0 012.287-.947c1.372.836 2.942-.734 2.106-2.106a1.532 1.532 0 01-.947-2.287c1.561-.379 1.561-2.6 0-2.978a1.532 1.532 0 01-.947-2.287c.836-1.372-.734-2.942-2.106-2.106A1.532 1.532 0 0111.49 3.17zM10 5.5a4.5 4.5 0 100 9 4.5 4.5 0 000-9zM10 7a3 3 0 100 6 3 3 0 000-6z" clip-rule="evenodd" />
                </svg>
            </button>
        </div>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const micButton = document.getElementById('micButton');
            const clearButton = document.getElementById('clearButton');
            const modeToggle = document.getElementById('modeToggle');
            const settingsButton = document.getElementById('settingsButton');
            const settingsPanel = document.getElementById('settings-panel');
            const overlay = document.getElementById('overlay');
            const themeToggle = document.getElementById('themeToggle');
            const langSelect = document.getElementById('lang-select');
            const minFontSizeInput = document.getElementById('min-font-size');
            const maxFontSizeInput = document.getElementById('max-font-size');
            const status = document.getElementById('status');
            const transcriptEl = document.getElementById('transcript');
            const textContainer = document.getElementById('text-container');
            const zoomIndicator = document.getElementById('zoom-indicator');
            let zoomTimeout;

            const openSettings = () => {
                settingsPanel.classList.add('is-open');
                overlay.classList.remove('hidden');
            };

            const closeSettings = () => {
                settingsPanel.classList.remove('is-open');
                overlay.classList.add('hidden');
            };

            settingsButton.addEventListener('click', openSettings);
            overlay.addEventListener('click', closeSettings);

            // --- THEME LOGIC ---
            const applyTheme = (theme) => {
                if (theme === 'dark') {
                    document.documentElement.classList.add('dark');
                } else {
                    document.documentElement.classList.remove('dark');
                }
                themeToggle.checked = (theme === 'dark');
            };

            themeToggle.addEventListener('change', () => {
                const newTheme = themeToggle.checked ? 'dark' : 'light';
                localStorage.setItem('voiceNoteTheme_v1', newTheme);
                applyTheme(newTheme);
            });

            // --- LANGUAGE LOGIC ---
            const applyLang = (lang) => {
                recognition.lang = lang;
                langSelect.value = lang;
            };

            langSelect.addEventListener('change', () => {
                const newLang = langSelect.value;
                localStorage.setItem('voiceNoteLang_v1', newLang);
                applyLang(newLang);
                // Redémarrer l'écoute si elle est active pour appliquer la nouvelle langue
                if (isListening) {
                    recognition.stop();
                }
            });

            minFontSizeInput.addEventListener('change', (e) => {
                const newMinSize = parseInt(e.target.value, 10);
                if (!isNaN(newMinSize) && newMinSize > 0) {
                    minFontSize = newMinSize;
                    localStorage.setItem('voiceNoteMinFontSize_v1', minFontSize);
                }
            });

            maxFontSizeInput.addEventListener('change', (e) => {
                const newMaxSize = parseInt(e.target.value, 10);
                if (!isNaN(newMaxSize) && newMaxSize > minFontSize) {
                    maxFontSize = newMaxSize;
                    localStorage.setItem('voiceNoteMaxFontSize_v1', maxFontSize);
                }
            });

            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (!SpeechRecognition) {
                status.textContent = "Désolé, la reconnaissance vocale n'est pas supportée.";
                micButton.disabled = true; modeToggle.disabled = true; return;
            }

            const recognition = new SpeechRecognition();
            recognition.lang = 'fr-FR';
            recognition.interimResults = true;

            let isListening = false;
            let finalTranscript = '';
            let sessionTranscript = '';
            let isAlwaysOn = false;
            let userStopped = false;
            let minFontSize = 12;
            let maxFontSize = 120;

            const scrollToBottom = () => textContainer.scrollTop = textContainer.scrollHeight;

            const loadState = () => {
                // Theme
                const savedTheme = localStorage.getItem('voiceNoteTheme_v1') || (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
                applyTheme(savedTheme);

                // Language
                const savedLang = localStorage.getItem('voiceNoteLang_v1') || 'fr-FR';
                applyLang(savedLang);

                // Font size limits
                minFontSize = parseInt(localStorage.getItem('voiceNoteMinFontSize_v1') || '12', 10);
                maxFontSize = parseInt(localStorage.getItem('voiceNoteMaxFontSize_v1') || '120', 10);
                minFontSizeInput.value = minFontSize;
                maxFontSizeInput.value = maxFontSize;

                // Transcript
                finalTranscript = localStorage.getItem('voiceNoteText_v11') || '';
                transcriptEl.textContent = finalTranscript;
                textContainer.style.fontSize = localStorage.getItem('voiceNoteFontSize_v11') || '22px';
                isAlwaysOn = localStorage.getItem('voiceNoteMode_v11') === 'true';
                modeToggle.checked = isAlwaysOn;
                updateMicMode();
                scrollToBottom();
            };

            const updateUIState = (isRecording) => {
                if (isRecording) {
                    micButton.classList.add('is-listening', 'bg-red-500');
                    micButton.classList.remove('bg-blue-600');
                    status.textContent = "J'écoute...";
                } else {
                    micButton.classList.remove('is-listening', 'bg-red-500');
                    micButton.classList.add('bg-blue-600');
                    status.textContent = isAlwaysOn ? "Cliquez sur le micro" : "Maintenez pour parler";
                }
            };
            
            const updateMicMode = () => {
                isAlwaysOn = modeToggle.checked;
                localStorage.setItem('voiceNoteMode_v11', isAlwaysOn);
                recognition.continuous = isAlwaysOn;
                if (isListening) recognition.stop();
                updateUIState(false);
            };

            const startListening = (e) => {
                if (e) e.preventDefault();
                if (isListening) return;
                userStopped = false;
                isListening = true;
                recognition.start();
            };

            const stopListening = () => {
                if (!isListening) return;
                isListening = false;
                recognition.stop();
            };

            modeToggle.addEventListener('change', updateMicMode);
            micButton.addEventListener('click', (e) => {
                if (isAlwaysOn) {
                    if (isListening) {
                        userStopped = true;
                        stopListening();
                    } else {
                        startListening(e);
                    }
                }
            });
            micButton.addEventListener('mousedown', (e) => !isAlwaysOn && startListening(e));
            micButton.addEventListener('mouseup', () => !isAlwaysOn && stopListening());
            micButton.addEventListener('mouseleave', () => !isAlwaysOn && stopListening());
            micButton.addEventListener('touchstart', (e) => !isAlwaysOn && startListening(e), { passive: false });
            micButton.addEventListener('touchend', () => !isAlwaysOn && stopListening());

            clearButton.addEventListener('click', () => {
                finalTranscript = '';
                sessionTranscript = '';
                transcriptEl.textContent = '';
                localStorage.setItem('voiceNoteText_v11', '');
                status.textContent = "Texte effacé";
            });

            recognition.onstart = () => {
                sessionTranscript = '';
                updateUIState(true);
            };
            
            recognition.onresult = (event) => {
                let interimTranscript = '';
                let sessionFinal = '';

                for (let i = 0; i < event.results.length; ++i) {
                    const transcriptPart = event.results[i][0].transcript;
                    if (event.results[i].isFinal) {
                        sessionFinal = transcriptPart;
                    } else {
                        interimTranscript = transcriptPart;
                    }
                }
                sessionTranscript = sessionFinal;
                transcriptEl.textContent = finalTranscript + sessionTranscript + interimTranscript;
                scrollToBottom();
                localStorage.setItem('voiceNoteText_v11', finalTranscript + sessionTranscript);
            };

            recognition.onend = () => {
                isListening = false;
                updateUIState(false);
                // Commit the session transcript to the final transcript
                if (sessionTranscript) {
                    finalTranscript += sessionTranscript.trim() + '\n';
                    sessionTranscript = ''; // Clear it
                }
                localStorage.setItem('voiceNoteText_v11', finalTranscript);

                // Si le mode continu est activé, redémarre la reconnaissance
                if (isAlwaysOn && !userStopped) {
                    startListening();
                }
            };

            recognition.onerror = (event) => {
                console.error("Erreur:", event.error);
                if (event.error !== 'no-speech') status.textContent = `Erreur: ${event.error}`;
                isListening = false;
                updateUIState(false);
            };

            // --- GESTION DU ZOOM & SCROLL ---
            let initialPinchDistance = null; let initialFontSize = 22;
            const getDistance = (touches) => Math.hypot(touches[0].pageX - touches[1].pageX, touches[0].pageY - touches[1].pageY);

            textContainer.addEventListener('touchstart', (e) => {
                if (e.touches.length === 2) {
                    e.preventDefault();
                    textContainer.style.touchAction = 'none';
                    initialPinchDistance = getDistance(e.touches);
                    initialFontSize = parseFloat(window.getComputedStyle(textContainer).fontSize);
                }
            }, { passive: false });

            textContainer.addEventListener('touchmove', (e) => {
                if (e.touches.length === 2 && initialPinchDistance) {
                    e.preventDefault();
                    const currentDistance = getDistance(e.touches);
                    const scale = currentDistance / initialPinchDistance;
                    let newSize = initialFontSize * scale;

                    // Ajout de l'effet de rebond
                    const bounceMargin = 20; // Marge de rebond de 20px
                    const softMin = minFontSize - bounceMargin;
                    const softMax = maxFontSize + bounceMargin;
                    newSize = Math.max(softMin, Math.min(newSize, softMax));

                    textContainer.style.fontSize = `${newSize}px`;

                    // Afficher l'indicateur si la taille min/max est atteinte ou dépassée
                    if (newSize <= minFontSize) {
                        zoomIndicator.textContent = `Taille min atteinte`;
                        zoomIndicator.classList.remove('opacity-0');
                        clearTimeout(zoomTimeout);
                    } else if (newSize >= maxFontSize) {
                        zoomIndicator.textContent = `Taille max atteinte`;
                        zoomIndicator.classList.remove('opacity-0');
                        clearTimeout(zoomTimeout);
                    } else {
                        // Masquer si on est de retour dans les limites
                        zoomIndicator.classList.add('opacity-0');
                    }
                }
            }, { passive: false });

            textContainer.addEventListener('touchend', (e) => {
                 if (initialPinchDistance) {
                    let finalSize = parseFloat(window.getComputedStyle(textContainer).fontSize);
                    let needsSnap = false;

                    if (finalSize < minFontSize) {
                        finalSize = minFontSize;
                        needsSnap = true;
                    } else if (finalSize > maxFontSize) {
                        finalSize = maxFontSize;
                        needsSnap = true;
                    }

                    if (needsSnap) {
                        // Appliquer la transition pour l'effet de rebond
                        textContainer.style.transition = 'font-size 0.2s ease-out';
                        textContainer.style.fontSize = `${finalSize}px`;
                        // Supprimer la transition après l'animation pour ne pas affecter le prochain zoom
                        setTimeout(() => {
                            textContainer.style.transition = '';
                        }, 200);
                    }

                    // Sauvegarder la taille de police finale
                    localStorage.setItem('voiceNoteFontSize_v11', `${finalSize}px`);
                    initialPinchDistance = null;

                    // Masquer l'indicateur après un délai
                    clearTimeout(zoomTimeout);
                    zoomTimeout = setTimeout(() => {
                        zoomIndicator.classList.add('opacity-0');
                    }, 1500);
                }
                textContainer.style.touchAction = 'pan-y';
            });

            loadState();
        });
    </script>
</body>
</html>
